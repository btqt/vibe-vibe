
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        img { max-width: 100%; height: auto; }
    </style>
</head>
<body>
<hr />
<h2>title: "Chương 9: Quy trình kiểm thử chức năng và kịch bản tự động hóa"</h2>
<h1>Chương 9: Quy trình kiểm thử chức năng và kịch bản tự động hóa</h1>
<h2>Lời tựa</h2>
<p>Tính năng ngày càng nhiều, bạn bắt đầu gặp phải hiện tượng đau đầu: <strong>"Đập chuột chũi"</strong>. Bạn vừa sửa xong Bug ở "Trang đăng nhập", kết quả "Trang đăng ký" lại không mở được; bạn tối ưu style trang chủ, kết quả nút giỏ hàng lại bấm không ăn.</p>
<p>Sư phụ bảo, muốn ngăn chặn thảm án "rút dây động rừng" kiểu này, phải nắm bắt cả hai tay: <strong>Đầu tiên là "Nội công": Quy hoạch hợp lý cấu trúc code và thư mục</strong>. Đừng chất đống logic vào một file, mà phải tách biệt các chức năng thành các module độc lập (ví dụ <code>components/</code> chứa khối component, <code>lib/</code> chứa hàm tiện ích, <code>app/</code> chứa trang). Cấu trúc rõ ràng rồi, sửa module A tự nhiên sẽ khó làm hỏng lây sang module B. <strong>Tiếp theo là "Ngoại công": Kiểm thử hồi quy (Regression Testing)</strong>. Mỗi lần sửa code, bạn đều phải test lại tất cả các tính năng từng chạy được trước đó, đảm bảo không bị code mới "làm hỏng". Nhưng dựa vào sức người ngồi bấm bấm trên web, vừa mệt vừa dễ sót.</p>
<p><strong>Tuy nhiên, sư phụ cũng đưa ra lời khuyên thực tế:</strong> Tự động hóa tuy sướng, nhưng không bắt buộc. Nếu dự án của bạn chỉ có 2 trang, hoặc đang ở giai đoạn sửa nhu cầu điên cuồng, thì cứ <strong>trực tiếp dùng tay bấm</strong> lại kinh tế hơn. Kiểm thử tự động là để giải quyết lao động <strong>quy mô lớn, lặp lại</strong>, đừng vì tự động hóa mà tự động hóa, rơi vào cái bẫy viết kịch bản test còn lâu hơn viết code.</p>
<p>::: tip Tỷ lệ đầu tư / thu hoạch của kiểm thử tự động
<strong>Khi nào cần kiểm thử tự động?</strong></p>
<p>✅ <strong>Nên tự động hóa</strong>:</p>
<ul>
<li>Dự án có 5+ trang</li>
<li>Quy trình nghiệp vụ cốt lõi vượt quá 3 bước</li>
<li>Quy mô team trên 2 người</li>
<li>Cần sửa code thường xuyên</li>
<li>Đã từng gặp tình trạng "Sửa Bug A đẻ ra Bug B"</li>
</ul>
<p>❌ <strong>Khoan hẵng tự động hóa</strong>:</p>
<ul>
<li>Giai đoạn kiểm chứng Prototype (nhu cầu thay đổi liên tục)</li>
<li>Dự án dùng một lần (làm xong không bảo trì nữa)</li>
<li>Trang quá đơn giản (như trang tĩnh)</li>
</ul>
<p><strong>Ghi nhớ</strong>: Test là để nâng cao sự tự tin, chứ không phải để hoàn thành nhiệm vụ
:::</p>
<h3>Playwright</h3>
<p>Sư phụ giới thiệu <strong>Playwright</strong>. Bạn có thể hiểu nó là <strong>công cụ điều khiển trình duyệt tự động</strong>. Nó sở hữu một nhân trình duyệt thực thụ, có thể dùng tốc độ nhanh gấp 100 lần con người để mô phỏng thao tác click chuột, gõ phím thậm chí upload file của bạn. Quan trọng hơn, nó <strong>không biết mệt</strong>. Dù là 3 giờ sáng, chỉ cần bạn ra lệnh, nó có thể chạy lại quy trình "Đăng nhập - Đặt hàng - Thanh toán" 100 lần trong vài giây, mà tuyệt đối không nhìn nhầm.</p>
<p>Tại sao chọn Playwright chứ không phải framework test khác? Đầu tiên nó đa trình duyệt (hỗ trợ cả Chrome, Firefox, Safari), thứ hai nhanh và ổn định (hỗ trợ chạy song song, tự động đợi phần tử xuất hiện), quan trọng nhất là thân thiện với AI —— có thể dùng <code>npx playwright codegen</code> ghi lại thao tác thủ công, tự động sinh code test. Khái niệm cốt lõi của Playwright rất đơn giản: Page đại diện trang trình duyệt, Locator dùng để định vị phần tử, Assertion dùng để khẳng định phán đoán. Lý thuyết tháp kiểm thử khuyên dùng 60% Unit Test, 30% Integration Test, 10% E2E Test. E2E Test tuy chiếm tỷ trọng nhỏ, nhưng bao phủ quy trình nghiệp vụ cốt lõi (đăng nhập, đăng ký, thanh toán), giá trị cao nhất. AI còn có thể giúp bạn tối ưu test case, thêm trường hợp biên và xử lý lỗi. Giá trị của test không phải phát hiện Bug, mà là ngăn chặn Bug hồi quy —— sửa Bug A không sinh ra Bug B.</p>
<p>Trong quá trình VibeCoding, viết kịch bản test không còn là đặc quyền của kỹ sư kiểm thử cao cấp, trong công cụ lập trình AI chín muồi, bạn chỉ cần <strong>trích dẫn</strong> file code nghiệp vụ của bạn trong khung chat (thường là gõ <code>@</code> chọn file, hoặc dán đường dẫn file, thậm chí kéo thả file vào khung chat). Tuy AI hiện tại rất thông minh, có thể tự lục lọi tìm code trong cả dự án, nhưng nếu bạn có thể <strong>chỉ định đường dẫn file thủ công</strong>, phản ứng của AI sẽ nhanh hơn nhiều, viết test cũng chuẩn hơn.</p>
<p>::: info Lộ trình học chương này
<strong>Phần cơ bản</strong> (Hiểu lý thuyết test):</p>
<ol>
<li>Lý thuyết tháp kiểm thử → Hiểu phân tầng kiểm thử</li>
<li>Chi tiết các loại kiểm thử → Biết khi nào dùng loại nào</li>
<li>Khái niệm Mock → Học cách cách ly phụ thuộc bên ngoài</li>
</ol>
<p><strong>Phần thực hành</strong> (Làm quen Playwright): 4. Cài đặt và cấu hình Playwright → Dựng môi trường test 5. Hướng dẫn toàn diện Playwright → Nắm vững API cốt lõi 6. Thực chiến UI Test → Viết test thực tế 7. Thực chiến API Test → Test giao diện Backend</p>
<p><strong>Phần nâng cao</strong> (Quy trình làm việc tự động): 8. Chi tiết quy trình TDD → Viết test trước viết code sau 9. Hooks Automation Test → Tự động chạy test trước khi commit 10. Checkpoint và Revert → Quản lý phiên bản code an toàn 11. Chạy test và Debug → Sửa test lỗi hiệu quả
:::</p>
<p>::: tip Hệ thống kiểm thử mới thời đại lập trình AI
<strong>Quy trình test truyền thống</strong> (Tốn thời gian):</p>
<pre><code>Tự viết code test (1 tiếng)
→ Chạy test
→ Sửa lỗi
→ Lặp lại
</code></pre>
<p><strong>Quy trình test hỗ trợ bởi AI</strong> (Nhanh):</p>
<pre><code>Để AI sinh test (10 giây)
→ Chạy test
→ Để AI sửa lỗi (10 giây)
→ Hoàn thành
</code></pre>
<p><strong>Chuyển đổi then chốt</strong>:</p>
<ul>
<li>Từ "Viết test thế nào" → Chuyển sang "Thiết kế test gì"</li>
<li>Từ "Viết thủ công" → Chuyển sang "Rà soát và điều chỉnh"</li>
<li>Từ "Độ phủ test" → Chuyển sang "Giá trị test"</li>
</ul>
<p><strong>Vai trò của bạn</strong>: Kiến trúc sư kiểm thử, chứ không phải thợ viết code test
:::</p>
<h3>UI Test</h3>
<p>Đối với kiểm thử giao diện người dùng (UI), bạn chỉ cần trích dẫn <code>app/login/page.tsx</code> (giả sử đây là trang đăng nhập của bạn) vào khung Chat, rồi ra lệnh: "<strong>Đọc file này, viết cho tôi một kịch bản test Playwright. Ngữ cảnh test bao gồm: 1. Nhập sai mật khẩu phải báo lỗi; 2. Nhập đúng mật khẩu phải chuyển hướng về trang chủ.</strong>" AI sẽ đọc ngay nội dung file bạn chỉ định, phân tích cấu trúc component, sinh ra code chứa đầy đủ quy trình định hướng, thao tác, xác thực một cách chính xác.</p>
<h3>API Test</h3>
<p>Ngoài test giao diện, sư phụ nhắc bạn đừng quên test giao diện Backend (API). Đôi khi trang web báo lỗi không phải do nút hỏng, mà do API backend sập. Playwright không chỉ mô phỏng được trình duyệt, mà còn có thể gửi HTTP request trực tiếp. Bạn không cần đi viết test cho từng API một, mà trực tiếp trích dẫn cả thư mục <code>app/api</code>, ra một chỉ thị vĩ mô cho AI:</p>
<blockquote>
<p><strong>“Đọc tất cả các file route trong thư mục <code>app/api</code>, hiểu logic nghiệp vụ của từng API. Sau đó sinh kịch bản test tương ứng cho mỗi API, bao phủ ngữ cảnh request bình thường (200 OK) và các ngữ cảnh request lỗi thường gặp (400/500).”</strong></p>
</blockquote>
<p>AI sẽ nhanh chóng duyệt qua đường dẫn bạn chỉ định, phân tích ra bạn có mười mấy API như đăng ký, đăng nhập, lấy danh sách bài viết..., và tự động sinh ra một bộ code test chặt chẽ cho chúng. Cách này tốc độ cực nhanh, giúp bạn nhanh chóng định vị xem rốt cuộc là vấn đề logic hiển thị Frontend hay vấn đề xử lý dữ liệu Backend.</p>
<h3>Chạy Test</h3>
<p>Cuối cùng, bạn học được cách chạy <code>npx playwright test</code>. Nhìn từng dòng <strong>PASS</strong> màu xanh chạy vùn vụt trong terminal, cảm giác an toàn đó chưa từng có. Điều này có nghĩa là code của bạn <strong>đáng tin cậy</strong> về mặt logic. Sư phụ còn dạy bạn mở <strong>chế độ trực quan (UI Mode)</strong> của Playwright. Nhìn cửa sổ trình duyệt tự động trên màn hình nháy liên tục, tự động điền form, bấm nút, lần đầu tiên bạn trải nghiệm cảm giác sướng rơn của phát triển công nghiệp hóa. Bạn đảm bảo được rằng trước khi đối mặt với người dùng thật, những Bug logic cấp thấp kia đã bị tiêu diệt từ trong trứng nước.</p>
<h3>Test Driven Development (TDD)</h3>
<p>Tuy nhiên, sư phụ bảo bạn, còn có cách chơi cao cấp hơn. Bạn hiện tại là viết code trước, rồi bù test sau, cái này gọi là phiên bản ngược của "Phát triển hướng kiểm thử (TDD)". Trong thời đại lập trình AI, <strong>TDD thực sự là viết test trước, rồi mới viết code</strong>. Tại sao làm thế? Khi bạn cho AI một mục tiêu test rõ ràng, biểu hiện của nó sẽ được nâng cao đáng kể.</p>
<p>Sư phụ giới thiệu cho bạn quy trình làm việc <strong>TDD</strong>:</p>
<ol>
<li><strong>Viết test trước</strong>: Viết test dựa trên cặp đầu vào/đầu ra kỳ vọng, nói rõ với AI bạn đang tiến hành TDD, tránh việc nó tạo ra các hiện thực hóa giả (mock).</li>
<li><strong>Chạy test, xác nhận thất bại</strong>: Ở giai đoạn này nói rõ với AI đừng viết bất kỳ code hiện thực hóa nào.</li>
<li><strong>Commit test</strong>: Khi bạn hài lòng với bài test, bảo AI commit test.</li>
<li><strong>Viết code, cho đến khi test thông qua</strong>: Bảo AI viết code để thông qua bài test, chỉ thị nó không được sửa code test. Thường cần vài lần lặp.</li>
<li><strong>Commit code</strong>: Khi bạn hài lòng với thay đổi, bảo AI commit code.</li>
</ol>
<p>Bạn thử một lần, phát hiện quá trình viết test thực ra chính là đang "thiết kế interface". Khi bạn viết test, bạn sẽ suy nghĩ "phương thức này nên nhận tham số gì, trả về kết quả gì", quá trình suy nghĩ này quan trọng hơn việc trực tiếp viết code. Tuy lúc đầu cảm thấy chậm, nhưng rất nhanh phát hiện số lần phải làm lại giảm hẳn. Quan trọng hơn, bạn phát hiện test thực ra là "công cụ thiết kế" tốt nhất, nó ép bạn phải nghĩ rõ interface và logic trước khi viết code.</p>
<p>Sư phụ bảo, sự tự động hóa này còn có thể tiến thêm bước nữa —— thông qua cấu hình <strong>Hooks</strong>, mỗi khi AI sửa code xong, tự động chạy test liên quan. Bạn không cần gõ lệnh thủ công, toàn bộ quy trình test sẽ tự động hoàn thành.</p>
<h3>Hooks Automation</h3>
<p>Sư phụ báo trước: "Cậu có thể cấu hình Git Hooks, để mỗi lần trước khi commit code tự động chạy test. Như vậy có thể sớm phát hiện vấn đề, tránh việc đẩy code có bug vào kho."</p>
</body>
</html>
