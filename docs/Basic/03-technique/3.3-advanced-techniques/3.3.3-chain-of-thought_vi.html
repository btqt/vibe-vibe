
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3.3.3 Chain Of Thought</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        img { max-width: 100%; height: auto; }
    </style>
</head>
<body>
<hr />
<h2>title: '3.3.3 Chain of Thought: Để AI "nghĩ một chút" rồi hãy trả lời'</h2>
<p><img alt="03-technique_3.3-advanced-techniques_3.3.3-chain-of-thought.png" src="../../../public/images/Basic/03-technique_3.3-advanced-techniques_3.3.3-chain-of-thought.png" /></p>
<h1>3.3.3 Chain of Thought: Để AI "nghĩ một chút" rồi hãy trả lời</h1>
<h2>Sau bài học này, bạn sẽ nắm được</h2>
<ul>
<li>Định nghĩa và nguyên lý của Chain of Thought (CoT - Chuỗi suy nghĩ)</li>
<li>Hai cách kích hoạt CoT</li>
<li>Bối cảnh CoT thực sự hiệu quả (dựa trên nghiên cứu mới nhất)</li>
<li>Cách viết Prompt CoT hiệu quả</li>
<li>Những hạn chế và lưu ý khi dùng CoT</li>
</ul>
<h2>Chain of Thought là gì</h2>
<p>Tư tưởng cốt lõi của Chain of Thought (Chuỗi suy nghĩ, gọi tắt là CoT) là: <strong>Để AI viết ra quá trình suy luận, thay vì đưa ra câu trả lời ngay lập tức</strong>.</p>
<p>Giống như bài kiểm tra toán yêu cầu "trình bày các bước giải", khi AI được yêu cầu thể hiện quá trình suy nghĩ, nó thường đưa ra câu trả lời chính xác hơn.</p>
<pre><code>❌ Hỏi trực tiếp:
Độ phức tạp thời gian của hàm này là bao nhiêu?

✅ Dùng CoT:
Hãy phân tích độ phức tạp thời gian của hàm này.
Đầu tiên, nhận diện cấu trúc vòng lặp trong code;
Sau đó, phân tích số lần thực thi của mỗi vòng lặp;
Cuối cùng, tính toán tổng độ phức tạp thời gian.
</code></pre>
<h2>Insight cốt lõi: CoT không phải vạn năng</h2>
<blockquote>
<p>"Chain of Thought chủ yếu có hiệu quả rõ rệt trong các nhiệm vụ toán học và suy luận ký hiệu, đối với các loại nhiệm vụ khác lợi ích khá hạn chế."
—— Bài báo năm 2024 "To CoT or not to CoT?"</p>
</blockquote>
<p>Kết luận nghiên cứu này rất quan trọng. Nó nói cho chúng ta biết:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Loại nhiệm vụ</th>
<th style="text-align: left;">Hiệu quả CoT</th>
<th style="text-align: left;">Lý do</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Tính toán toán học</td>
<td style="text-align: left;">✅ Tăng đáng kể</td>
<td style="text-align: left;">Cần suy luận nhiều bước, phân rã các bước có ích</td>
</tr>
<tr>
<td style="text-align: left;">Suy luận logic</td>
<td style="text-align: left;">✅ Tăng rõ rệt</td>
<td style="text-align: left;">Logic phức tạp cần chải chuốt từng bước</td>
</tr>
<tr>
<td style="text-align: left;">Phân tích code</td>
<td style="text-align: left;">✅ Có ích</td>
<td style="text-align: left;">Liên quan đến lồng ghép nhiều tầng và phán đoán điều kiện</td>
</tr>
<tr>
<td style="text-align: left;">Tạo văn bản</td>
<td style="text-align: left;">⚠️ Lợi ích hạn chế</td>
<td style="text-align: left;">Nhiệm vụ sáng tạo không cần suy luận quá nghiêm ngặt</td>
</tr>
<tr>
<td style="text-align: left;">Phân loại đơn giản</td>
<td style="text-align: left;">❌ Có thể chậm hơn</td>
<td style="text-align: left;">Thêm các bước không cần thiết</td>
</tr>
</tbody>
</table>
<p><strong>Đề xuất thực tiễn</strong>: Đừng dùng CoT cho mọi nhiệm vụ, chỉ dùng trong các bối cảnh cần suy luận.</p>
<h2>Hai cách kích hoạt</h2>
<h3>Cách 1: Câu thần chú</h3>
<p>Cách đơn giản nhất, chỉ cần thêm một câu vào cuối Prompt:</p>
<pre><code>Hãy phân tích điểm nghẽn hiệu năng của đoạn code này.
Let's think step by step.
</code></pre>
<p>Hoặc bản tiếng Việt:</p>
<pre><code>Hãy phân tích điểm nghẽn hiệu năng của đoạn code này.
Chúng ta hãy cùng suy nghĩ từng bước một.
</code></pre>
<p>Cách này đơn giản, nhưng các bước suy luận của AI có thể không đủ cấu trúc.</p>
<h3>Cách 2: Phân rã bước rõ ràng</h3>
<p>Cách kiểm soát tốt hơn, nói thẳng cho AI biết nên phân bước thế nào:</p>
<pre><code>Hãy phân tích điểm nghẽn hiệu năng của đoạn code này.

Các bước phân tích:
1. Đầu tiên, nhận diện cấu trúc vòng lặp và đệ quy trong code
2. Sau đó, tìm ra các tính toán lặp lại có thể có
3. Tiếp theo, kiểm tra xem việc lựa chọn cấu trúc dữ liệu có hợp lý không
4. Cuối cùng, đưa ra đề xuất tối ưu và hiệu quả kỳ vọng
</code></pre>
<p>Cách làm này đầu ra có cấu trúc hơn, thích hợp cho các bối cảnh cần góc độ phân tích cụ thể.</p>
<h2>Prompt dở vs Prompt tốt</h2>
<h3>Bối cảnh: Phân tích logic xác thực form</h3>
<h3>❌ Prompt dở</h3>
<pre><code>Logic xác thực form này có vấn đề gì không?

function validateForm(data) {
  if (data.email &amp;&amp; data.password &amp;&amp; data.password.length &gt;= 6) {
    if (data.email.includes('@')) {
      return true;
    }
  }
  return false;
}
</code></pre>
<p><strong>Vấn đề</strong>: AI có thể chỉ đưa ra một kết luận chung chung, bỏ sót một số trường hợp biên.</p>
<h3>✅ Prompt tốt (Sử dụng CoT)</h3>
<pre><code>Hãy kiểm tra hàm xác thực form này, xem có bỏ sót trường hợp xác thực nào không.

function validateForm(data) {
  if (data.email &amp;&amp; data.password &amp;&amp; data.password.length &gt;= 6) {
    if (data.email.includes('@')) {
      return true;
    }
  }
  return false;
}

Các bước phân tích:
1. Đầu tiên, liệt kê các điều kiện mà hàm này hiện tại đã kiểm tra
2. Sau đó, suy nghĩ xem xác thực form thông thường cần kiểm tra cái gì
3. Tiếp theo, đối chiếu tìm ra các mục xác thực bị bỏ sót
4. Cuối cùng, đưa ra đề xuất cải tiến
</code></pre>
<h3>Đầu ra của AI cho Prompt tốt</h3>
<pre><code>Quá trình phân tích:

1. Các điều kiện hiện tại đã kiểm tra:
   - email tồn tại và không rỗng
   - password tồn tại và không rỗng
   - password độ dài &gt;= 6
   - email chứa ký tự @

2. Xác thực form thông thường cần kiểm tra:
   - Tính toàn vẹn của định dạng email (trước sau @ đều phải có nội dung, phải có đuôi tên miền)
   - Độ mạnh của password (chữ hoa thường, số, ký tự đặc biệt)
   - Ngăn chặn SQL Injection và XSS
   - Xử lý ký tự khoảng trắng

3. Các mục xác thực bị bỏ sót:
   - Định dạng email không đầy đủ: &quot;@&quot; hoặc &quot;a@&quot; hoặc &quot;@b&quot; đều có thể lọt qua
   - Password chỉ kiểm tra độ dài, không kiểm tra độ mạnh
   - Không xử lý khoảng trắng ở đầu và cuối
   - Không xác thực đuôi tên miền của email (ví dụ .com)

4. Đề xuất cải tiến:
   - Sử dụng biểu thức chính quy (Regex) để xác thực định dạng email
   - Thêm kiểm tra độ mạnh mật khẩu
   - Dùng trim() để xử lý đầu vào
</code></pre>
<h2>Bảng quyết định bối cảnh áp dụng</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Bối cảnh</th>
<th style="text-align: left;">Có dùng CoT không</th>
<th style="text-align: left;">Lý do</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Tính độ phức tạp thời gian/không gian</td>
<td style="text-align: left;">✅ Dùng</td>
<td style="text-align: left;">Cần phân tích lồng ghép vòng lặp</td>
</tr>
<tr>
<td style="text-align: left;">Review logic code</td>
<td style="text-align: left;">✅ Dùng</td>
<td style="text-align: left;">Cần xem xét nhiều nhánh và điều kiện biên</td>
</tr>
<tr>
<td style="text-align: left;">Thiết kế cấu trúc bảng cơ sở dữ liệu</td>
<td style="text-align: left;">✅ Dùng</td>
<td style="text-align: left;">Cần phân tích quan hệ thực thể</td>
</tr>
<tr>
<td style="text-align: left;">Debug nguyên nhân lỗi</td>
<td style="text-align: left;">✅ Dùng</td>
<td style="text-align: left;">Cần rà soát từng bước</td>
</tr>
<tr>
<td style="text-align: left;">Chuyển đổi định dạng code đơn giản</td>
<td style="text-align: left;">❌ Không dùng</td>
<td style="text-align: left;">Chuyển đổi trực tiếp là được</td>
</tr>
<tr>
<td style="text-align: left;">Viết một đoạn văn案</td>
<td style="text-align: left;">❌ Không dùng</td>
<td style="text-align: left;">Nhiệm vụ sáng tạo không cần suy luận nghiêm ngặt</td>
</tr>
<tr>
<td style="text-align: left;">Đổi tên biến</td>
<td style="text-align: left;">❌ Không dùng</td>
<td style="text-align: left;">Nhiệm vụ quá đơn giản</td>
</tr>
</tbody>
</table>
<h2>Ví dụ thực chiến: Dự án danh sách việc cần làm</h2>
<p>Tiểu Lý muốn nhờ AI giúp phân tích một lỗi Bug: Sau khi xóa nhiệm vụ, đôi khi trang không cập nhật.</p>
<h3>Prompt CoT</h3>
<pre><code>Ứng dụng danh sách việc cần làm của tôi có một Bug: Sau khi xóa nhiệm vụ, thỉnh thoảng trang không cập nhật.

Dưới đây là code liên quan:

// Trạng thái danh sách nhiệm vụ
const [tasks, setTasks] = useState([]);

// Xóa nhiệm vụ
const deleteTask = (id) =&gt; {
  tasks.splice(tasks.findIndex(t =&gt; t.id === id), 1);
  setTasks(tasks);
}

Vui lòng giúp tôi phân tích nguyên nhân vấn đề.

Các bước phân tích:
1. Đầu tiên, hiểu cơ chế cập nhật trạng thái của React
2. Sau đó, kiểm tra cách cập nhật trạng thái của đoạn code này
3. Tiếp theo, tìm ra nguyên nhân dẫn đến không cập nhật
4. Cuối cùng, đưa ra phương án sửa chữa
</code></pre>
<h3>Đầu ra của AI</h3>
<pre><code>Quá trình phân tích:

1. Cơ chế cập nhật trạng thái của React:
   React quyết định có render lại hay không bằng cách so sánh tham chiếu (reference) của trạng thái mới và cũ.
   Nếu tham chiếu của đối tượng trạng thái không đổi, React cho rằng trạng thái không thay đổi.

2. Vấn đề của code hiện tại:
   - splice() sửa đổi trực tiếp trên mảng gốc
   - setTasks(tasks) truyền vào vẫn là tham chiếu của mảng đó
   - React so sánh thấy tham chiếu giống nhau, không kích hoạt render lại

3. Nguyên nhân gốc rễ:
   Sửa đổi trực tiếp mảng gốc (mutation) thay vì tạo mảng mới (immutation)

4. Phương án sửa chữa:
   Sử dụng filter để tạo mảng mới:

   const deleteTask = (id) =&gt; {
     setTasks(tasks.filter(t =&gt; t.id !== id));
   }

   Hoặc sử dụng toán tử spread:

   const deleteTask = (id) =&gt; {
     const newTasks = [...tasks];
     newTasks.splice(newTasks.findIndex(t =&gt; t.id === id), 1);
     setTasks(newTasks);
   }
</code></pre>
<h2>Concise CoT: Bản tinh gọn</h2>
<p>Nếu bạn muốn tiết kiệm token, có thể dùng phiên bản CoT tinh gọn:</p>
<pre><code>Hãy phân tích tóm tắt độ phức tạp thời gian của hàm này, dùng 2-3 câu giải thích quá trình suy luận, rồi đưa ra kết luận.
</code></pre>
<p>Nghiên cứu chỉ ra rằng, Concise CoT có thể giảm khoảng 50% độ dài đầu ra, đồng thời vẫn giữ được phần lớn độ chính xác của suy luận.</p>
<h2>Hạn chế của CoT</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Hạn chế</th>
<th style="text-align: left;">Biểu hiện</th>
<th style="text-align: left;">Cách đối phó</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Tăng độ dài đầu ra</td>
<td style="text-align: left;">Tiêu tốn Token tăng 20-80%</td>
<td style="text-align: left;">Dùng Concise CoT hoặc giới hạn số chữ</td>
</tr>
<tr>
<td style="text-align: left;">Một số nhiệm vụ lại kém đi</td>
<td style="text-align: left;">Nhiệm vụ đơn giản ép phân bước có thể sai</td>
<td style="text-align: left;">Tùy bối cảnh chọn có dùng hay không</td>
</tr>
<tr>
<td style="text-align: left;">Suy luận có thể sai</td>
<td style="text-align: left;">Sai một bước, sai cả dây</td>
<td style="text-align: left;">Kết hợp Self-Critique để kiểm tra</td>
</tr>
</tbody>
</table>
<h2>Mẫu có thể sao chép</h2>
<h3>Mẫu CoT phân tích code</h3>
<pre><code class="language-markdown">Hãy phân tích [Mục tiêu phân tích: Hiệu năng/Bảo mật/Khả năng bảo trì] của đoạn code sau:

[Code]

Các bước phân tích:

1. Đầu tiên, [Góc độ phân tích bước 1]
2. Sau đó, [Góc độ phân tích bước 2]
3. Tiếp theo, [Góc độ phân tích bước 3]
4. Cuối cùng, đưa ra kết luận và đề xuất
</code></pre>
<h3>Mẫu CoT rà soát vấn đề</h3>
<pre><code class="language-markdown">Mô tả vấn đề: [Hiện tượng vấn đề]

Code/Cấu hình liên quan:
[Code hoặc cấu hình]

Vui lòng giúp tôi phân tích nguyên nhân vấn đề.

Các bước rà soát:

1. Đầu tiên, hiểu xem trong tình huống bình thường thì nó hoạt động thế nào
2. Sau đó, kiểm tra quy trình thực thi của code hiện tại
3. Tiếp theo, định vị khâu có thể gây ra vấn đề
4. Cuối cùng, đưa ra phương án sửa chữa
</code></pre>
<h3>Mẫu CoT tinh gọn</h3>
<pre><code class="language-markdown">Hãy phân tích [Nhiệm vụ].
Dùng 2-3 câu giải thích quá trình suy luận của bạn, sau đó đưa ra kết luận.
</code></pre>
<h2>Trọng điểm bài học</h2>
<p>✓ <strong>Bản chất của CoT</strong>: Để AI thể hiện quá trình suy luận, không phải đưa đáp án ngay</p>
<p>✓ <strong>Bối cảnh hiệu quả</strong>: Toán học, suy luận logic, phân tích code, rà soát vấn đề</p>
<p>✓ <strong>Hai cách kích hoạt</strong>: Câu thần chú (đơn giản) vs Phân rã bước rõ ràng (dễ kiểm soát)</p>
<p>✓ <strong>Đừng lạm dụng</strong>: Nhiệm vụ đơn giản không cần CoT, dùng ngược lại còn giảm hiệu quả</p>
<p>✓ <strong>Concise CoT</strong>: Dùng bản tinh gọn khi cần tiết kiệm token</p>
<p>Bài sau, chúng ta sẽ học cách để AI khám phá nhiều con đường suy nghĩ —— Tree of Thoughts.</p>
</body>
</html>
