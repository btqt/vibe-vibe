
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>01 Vibe Coding Methodology</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        img { max-width: 100%; height: auto; }
    </style>
</head>
<body>
<hr />
<h2>title: "Một chút chia sẻ kinh nghiệm Vibe Coding - Từ người thực thi đến người ra quyết định"</h2>
<p><img alt="alt text" src="../../public/images/practice-01-vibe-coding-methodology.png" /></p>
<p>Đây không phải là một bài "chia sẻ trải nghiệm Vibecoding dành cho người mới hoàn toàn". Điều tôi muốn chia sẻ là một loại kinh nghiệm thực chiến khác —— khi bản thân bạn đã có đủ năng lực phát triển backend, làm thế nào để dựa vào công cụ mạnh mẽ AI này để tạo đòn bẩy hiệu suất cho chính mình, nâng cao đáng kể hiệu quả công việc. Hãy để AI trở thành một "tầng thực thi" cực kỳ hiệu quả, trong khi quyền quyết định vẫn nằm trong tay bạn, giải phóng bản thân khỏi công việc coding lặp đi lặp lại, tập trung vào thiết kế kiến trúc và kiểm soát quyết định. Hãy thoát khỏi những việc vặt ở tầng thực thi để trở thành kiến trúc sư và người ra quyết định thực thụ. Đồng thời, điều này cũng giúp bạn thoải mái hơn trong công việc vụn vặt hàng ngày, có nhiều năng lượng hơn để viết lách, suy ngẫm, hay đơn giản là nghỉ ngơi một chút.</p>
<h2>1. Hiểu biết sơ bộ về Vibe Coding</h2>
<p>Do khái niệm Vibe Coding đang trở nên "hot", nên khi nhắc đến từ này, điều đầu tiên chúng ta nghĩ đến thường là: một bạn có khao khát khám phá mãnh liệt nhưng không có nền tảng lập trình, sử dụng ngôn ngữ tự nhiên để mô tả ý tưởng của mình, thông qua các CodingIDE để tương tác với mô hình, để mô hình lớn giúp bạn tạo ra một đống thứ, và cuối cùng tạo ra một sản phẩm hoàn chỉnh một cách thành công. Rất có cảm giác thành tựu, nhưng thực ra bạn chẳng biết mô hình lớn đã làm gì, hoàn toàn mù tịt về hệ thống, mặc dù có một quy trình thực thi hoàn chỉnh nhưng vẫn thiếu hiểu biết sâu sắc về cơ chế bên trong. Khi vận hành thực tế thì bug bay lung tung, mà bản thân mô hình lớn lại có điểm mù trong việc tự nhận thức và sửa sai, cuối cùng rất dễ rơi vào tình trạng luẩn quẩn tại chỗ, tâm lý bùng nổ, gặp phải trần nhà của sự sáng tạo.</p>
<p>Đối với một người đã có đủ năng lực phát triển như tôi, tôi cũng hợp tác với mô hình lớn, nhưng cách hợp tác có chút khác biệt. Cụ thể là chậm lại một chút. Tốc độ tạo code của mô hình lớn đã đủ nhanh rồi, không cần nhanh hơn nữa. Điều tôi cần làm là để mô hình lớn chậm lại, ưu tiên sự ổn định, chạy bước nhỏ, chắc chắn từng bước, từ đó xây dựng một nhịp điệu phát triển có thể kiểm soát và một kiến trúc hệ thống phức tạp, ổn định hơn.</p>
<p>Tôi đã phát triển vô số nhu cầu CRUD, nên tôi rất rõ về quy trình phát triển hoàn chỉnh. Tôi biết chi tiết từng khâu từ phân tích nhu cầu, thiết kế kiến trúc, triển khai code đến kiểm thử triển khai, cũng như mối quan hệ phụ thuộc và luồng dữ liệu giữa các module. Điều này cho phép tôi hướng dẫn mô hình lớn tạo ra code đúng như mong đợi tốt hơn.</p>
<p>Vì vậy, khi đối mặt với nhu cầu mới, tôi sẽ dựa vào kinh nghiệm phát triển của bản thân để nhanh chóng chắt lọc các module cốt lõi và logic then chốt, thiết kế bản vẽ cho toàn bộ hệ thống. Tất nhiên trong quá trình này tôi cũng liên tục tương tác với mô hình lớn, để nó giúp tôi rà soát xem tư duy triển khai còn vấn đề gì không, sau đó chia nhỏ thành các component có ranh giới rõ ràng, chức năng cụ thể, và sắp xếp rõ ràng mối quan hệ luồng dữ liệu giữa các component này. Cuối cùng để mô hình lớn điền vào chi tiết và thực hiện trong khuôn khổ này. Khi phát triển, nếu có bug, tôi cũng là người định vị. Chủ yếu là vì mô hình lớn đôi khi rất ngốc, cứ luẩn quẩn lặp lại ở một chỗ, lại còn làm ăn bớt xén. Đây là nói mô hình thông minh một chút đấy, nếu bạn gặp mô hình ngốc hơn, chuyện nó xóa database bỏ chạy không phải là giấc mơ đâu. Cho nên, tôi sẽ tự xem bug hoặc nguyên nhân báo lỗi trước, có phán đoán sơ bộ, rồi dẫn dắt mô hình đi phân tích và định vị vấn đề. Về bản chất, mô hình lớn giống như một người mới vào nghề do tôi hướng dẫn, rất tháo vát, nhưng thỉnh thoảng lại phạm sai lầm ngớ ngẩn, nên tôi phải luôn giữ vô lăng trong tay mình.</p>
<p>Trong quá trình vibeCoding trước đây, tuy tích lũy được nhiều mẹo nhỏ, ví dụ như bạn phải học cách "mắng nó", bạn phải biết cấu hình các quy tắc code rule để mô hình lớn tuân thủ, nhưng những cái này không có cũng chẳng sao. Trong đó tôi cảm thấy có hai tư duy vibeCoding có thể cấu thành phương pháp luận, không nhiều, chỉ có hai cái.</p>
<p>Cái thứ nhất là <strong>Giải pháp đi trước, Triển khai theo sau</strong>. Tôi phát hiện ra rằng mặc dù không thể đi thẳng từ PRD đến giải pháp kỹ thuật, nhưng trước khi thực hiện mỗi tính năng, hãy để mô hình lớn xuất ra một giải pháp triển khai kỹ thuật trước. Tôi sẽ review và tinh chỉnh, sau đó mới dựa vào giải pháp này để bảo nó viết code. Hiệu quả tốt hơn nhiều so với việc dùng một câu nói bắt nó tạo code ngay, và cũng dễ kiểm soát hơn, ít bug hơn. Tại sao lại như vậy? Vì giải pháp triển khai do mô hình lớn tạo ra, chính nó cũng dễ hiểu hơn. Bạn để nó sắp xếp suy nghĩ rõ ràng và viết ra trước, khi nó viết code sau đó sẽ có một điểm neo rõ ràng, không dễ bị lệch hướng. Còn nếu bạn trực tiếp bảo nó viết code một bước là xong, thực ra nó đang "vừa nghĩ vừa viết", ở giữa rất dễ xuất hiện đứt gãy logic hoặc trước sau không nhất quán. Mẹo này cũng áp dụng được trong các bối cảnh khác, ví dụ khi tạo ảnh, hãy để mô hình lớn xuất ra mô tả hình ảnh trước, rồi dựa vào mô tả đó để tạo ảnh, sẽ dễ kiểm soát hơn nhiều so với việc bảo nó tạo ảnh ngay lập tức. Bản chất đây là một ứng dụng của "chuỗi suy nghĩ" (Chain of Thought) —— chia một nhiệm vụ phức tạp thành hai bước "nghĩ kỹ rồi hãy làm", mỗi bước đều dễ kiểm soát hơn, kết quả cuối cùng cũng ổn định hơn.</p>
<p>Cụ thể khi triển khai một module đơn lẻ: Trước tiên mô tả thực thể nghiệp vụ để AI đưa ra một bản cấu trúc bảng, tôi xem xét điều chỉnh. Sau đó bảo nó tạo code ba tầng DAO, Service, Controller một lần (đây là sân nhà của AI làm việc tay chân, khối lượng công việc truyền thống làm cả ngày nó làm trong 2 phút, hơn nữa kiểm tra biên, xử lý ngoại lệ, ghi log đều rất đầy đủ). Tiếp theo tạo tài liệu API rồi bảo nó tạo trang Frontend. Cuối cùng tôi chạy thử CRUD một lần để xác minh đầu cuối, gặp vấn đề tôi định vị tầng cụ thể rồi bảo nó sửa. Với các kịch bản có quy tắc nghiệp vụ như kiểm soát quyền hạn, tôi nói rõ quy tắc nghiệp vụ cho AI, không thể trông chờ nó tự đoán.</p>
<p>Dựa trên mô hình phát triển như vậy, thực ra cũng vô hình trung xây dựng cho Vibe Coding một môi trường vận hành quan trọng <strong>có bộ nhớ</strong>. Thông qua tài liệu để lưu trữ (persist) các bản ghi đối thoại quan trọng, quyết định kỹ thuật, các hố đã giẫm phải. Như vậy hình thành một môi trường ngữ cảnh bao gồm toàn bộ đầu vào: tài liệu nhu cầu, code, cấu trúc bảng database, định nghĩa API, giải pháp kỹ thuật lịch sử, v.v. Các giải pháp kỹ thuật đã làm trước đó cũng được lưu lại, gặp kịch bản tương tự thì tái sử dụng trực tiếp, không cần làm lại từ đầu.</p>
<p>Môi trường này chính là một kho tri thức trong phát triển VibeCoding, giúp bạn có thể nhanh chóng quay lại trạng thái trước đó bất cứ lúc nào, tiếp tục công việc phát triển. Làm sao để cơ chế đồng bộ này tự động vận hành? Thực ra tư duy sắp xếp tài liệu của tôi rất giống với đại lão phát triển laper.ai, nhưng tôi thấy anh ấy viết hay hơn, nên tôi bê nguyên tư duy của anh ấy sang đây:</p>
<pre><code>Cấu trúc tài liệu phân hình (Fractal):
Thư mục gốc đặt một file md chính, nhấn mạnh mọi cập nhật về tính năng, kiến trúc, cách viết code bắt buộc phải cập nhật đồng bộ vào các tài liệu con liên quan ngay sau khi kết thúc công việc;
Mỗi thư mục đều có một mô tả kiến trúc cực giản (trong vòng 3 dòng), bên dưới liệt kê tên, vị trí, chức năng của từng file, đầu file tuyên bố &quot;một khi thư mục chứa tôi có thay đổi, xin hãy cập nhật tôi&quot;;
Đầu mỗi file code viết 3 dòng chú thích cực giản —— input (phụ thuộc bên ngoài cái gì), output (cung cấp cái gì ra bên ngoài), pos (vị trí cục bộ trong hệ thống là gì), và ghi rõ &quot;một khi tôi bị cập nhật, nhất định phải cập nhật chú thích đầu file của tôi và md của thư mục chứa tôi&quot;.
Bạn sẽ phát hiện đây là một cấu trúc phân hình tự tham chiếu, cục bộ ảnh hưởng toàn thể, toàn thể ảnh hưởng cục bộ, giống như Phức điệu và Tự tham chiếu trong &quot;Gödel, Escher, Bach&quot;. Một khi làm như vậy, AI khi sửa bất kỳ file nào đều sẽ tự động kích hoạt một chuỗi đồng bộ tài liệu, ngữ cảnh mãi mãi sống động, phản ứng hóa học tự lan ra.
</code></pre>
<p>Cái thứ hai là <strong>đi chậm bước nhỏ, chắc chắn từng bước</strong>. Cách làm cụ thể là: trong quá trình phát triển dự án, chia các module tính năng lớn thành nhiều nhiệm vụ nhỏ có thể hoàn thành độc lập. Mỗi nhiệm vụ nhỏ đều bao gồm mục tiêu, giải pháp kỹ thuật và các bước thực hiện rõ ràng. Sau khi hoàn thành một nhiệm vụ nhỏ, lập tức cập nhật tài liệu liên quan và chú thích code, đảm bảo ngữ cảnh toàn bộ dự án luôn ở trạng thái mới nhất. Điều này giúp tránh vấn đề thông tin bị chậm trễ hoặc sai lệch trong quá trình phát triển, đồng thời cũng giúp việc bảo trì và lặp lại sau này trở nên dễ dàng hơn.</p>
<p>Đồng thời, cuối mỗi bước đều có thể đi kiểm chứng. Trong vibeCoding, Unit Test hoặc kiểm thử chức năng chi tiết trở nên ngày càng quan trọng. Bạn rất dễ dàng để mô hình lớn dựng cho bạn công cụ hoặc script test, thậm chí trang test demo, những việc này chẳng tốn mấy sức lực, nhưng lại giúp bạn tiết kiệm đáng kể vấn đề mô hình lớn quay mòng mòng tại chỗ khi bug dồn đống và bùng nổ tập trung sau này.</p>
<h2>2. Tôi đã làm dự án gì, làm như thế nào</h2>
<h3>Bối cảnh dự án và nhu cầu</h3>
<p>Dự án tôi làm là một <strong>Hệ thống quản lý dịch vụ file streaming</strong>, nói toạc ra là giúp đội ngũ vận hành quản lý các file hình ảnh video từ camera. Từ việc kéo luồng (pull stream) thiết bị camera, chuyển mã (transcode), lưu trữ, phân phối, đến việc phát lại, tải xuống, xóa, sao lưu file video cũng như lưu trữ file media hết hạn. Đây không phải là một công cụ quản lý file đơn giản, mà là một nền tảng quản lý tài nguyên media "tất cả trong một" (one-stop).</p>
<p>Trong hệ thống này liên quan đến hai module chức năng cốt lõi: Module quản lý tài nguyên media và Module quản lý quyền truy cập file.</p>
<p><strong>Module chức năng cốt lõi:</strong></p>
<ul>
<li><strong>Hệ thống quyền hạn</strong>: Phân tách quyền hạn ba vai trò Admin siêu cấp, Quản trị viên không gian, Thành viên thường. Quản lý &amp; Xác thực API Key. Kiểm soát quyền thêm xóa thành viên. API mở cho bên thứ ba tích hợp.</li>
<li><strong>Quản lý tài nguyên media</strong>: Hỗ trợ đa định dạng (video, ảnh), tự động chuyển mã sang nhiều quy cách, trích xuất thông tin meta (thời lượng, độ phân giải, bitrate...), hiển thị đa dạng (danh sách, lưới, dòng thời gian), chiến lược tự động dọn dẹp file hết hạn.</li>
<li><strong>Chi tiết trải nghiệm</strong>: Thao tác hàng loạt (upload hàng loạt, xóa hàng loạt, chuyển mã hàng loạt), phát realtime và lịch sử phát lại, tải xuống sao lưu video, tìm kiếm và lọc.</li>
</ul>
<h3>Chiến lược phát triển: Thiết kế từ trên xuống, chia nhỏ chức năng; Triển khai từ dưới lên, đẩy mạnh từng module</h3>
<p>Vì mô hình hiện tại vẫn chưa thể bàn giao hệ thống phức tạp một lần không bug, ngữ cảnh quá dài dễ khiến mô hình lạc lối rơi vào việc debug vô hiệu. Nên tôi áp dụng chiến lược <strong>từ trên xuống chi tiết hóa chức năng từng lớp, từ dưới lên triển khai từng module</strong>:</p>
<ol>
<li><strong>Giai đoạn bản vẽ toàn cục</strong>: Hình dung kiến trúc toàn bộ hệ thống trong đầu trước, bao gồm phân chia module cốt lõi, luồng dữ liệu, quan hệ phụ thuộc then chốt, sau đó xuất ra một tài liệu giải pháp hoàn chỉnh.</li>
<li><strong>Giai đoạn module cơ sở</strong>: Bắt đầu từ model dữ liệu và API tầng thấp nhất, hoàn thành xây dựng và kiểm thử module cơ sở trước, đảm bảo nền móng vững chắc.</li>
<li><strong>Giai đoạn module chức năng</strong>: Từng bước triển khai các module chức năng khác, mỗi module đều mở rộng dựa trên cơ sở đã có.</li>
<li><strong>Giai đoạn tích hợp</strong>: Cuối cùng xâu chuỗi logic cộng tác giữa các module, tiến hành kiểm thử tích hợp đầu cuối (E2E).</li>
</ol>
<p>Về bản chất cũng giống nhịp độ phát triển truyền thống, chỉ là mỗi khâu đều có AI hỗ trợ.</p>
<h3>Phân công vai trò Người - Máy</h3>
<p>Trong dự án lần này, tôi không hoàn toàn phụ thuộc vào Vibe Coding, mà thiết lập phân công rõ ràng:</p>
<table>
<thead>
<tr>
<th>Khâu</th>
<th>Trách nhiệm của tôi</th>
<th>Trách nhiệm của AI</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Thiết kế giải pháp</strong></td>
<td>Quyết định kiến trúc, thiết kế ranh giới quyền hạn, chọn công nghệ</td>
<td>Review giải pháp, phân tích tính khả thi, bổ sung chi tiết</td>
</tr>
<tr>
<td><strong>Triển khai code</strong></td>
<td>Rà soát giải pháp, Code Review, gỡ lỗi then chốt</td>
<td>Việc tay chân (CRUD, tài liệu API, tạo giao diện, đồng bộ trường)</td>
</tr>
<tr>
<td><strong>Định vị vấn đề</strong></td>
<td>Phân tích nguyên nhân gốc, chẩn đoán vấn đề</td>
<td>Sửa chữa dựa trên hướng dẫn</td>
</tr>
<tr>
<td><strong>Kiểm thử xác minh</strong></td>
<td>Thiết kế test, bổ sung ngữ cảnh biên</td>
<td>Tạo script test, dựng trang demo</td>
</tr>
</tbody>
</table>
<p><strong>Nguyên tắc then chốt:</strong></p>
<ul>
<li>Tôi không cần đọc hiểu từng dòng code, nhưng phải nắm rõ trách nhiệm cốt lõi và phạm vi ảnh hưởng của mỗi module.</li>
<li>Từ dưới lên dễ kiểm soát hơn là "PRD một phát ăn ngay", có thể kịp thời phát hiện vấn đề.</li>
<li>AI giỏi việc tay chân, Người giỏi phán đoán và khép kín vấn đề.</li>
</ul>
<h3>Thành quả dự án và nâng cao hiệu suất</h3>
<p>Cả dự án từ khi khởi động đến khi kết thúc, phần thực sự cần viết tay chiếm khoảng <strong>1%</strong>, chủ yếu bao gồm:</p>
<ul>
<li>Tinh chỉnh câu chữ (văn bản nhắc từ chối quyền, nhắc lỗi, hướng dẫn quy trình xin cấp quyền SOP)</li>
<li>Dọn dẹp import vô dụng (AI thi thoảng import thư viện không cần thiết), dọn dẹp hàm định nghĩa trùng lặp dư thừa, dọn dẹp chú thích vô dụng</li>
<li>Lỗi biên dịch lác đác do ảo giác AI (API hư cấu, sai phiên bản thư viện)</li>
<li>Tinh chỉnh logic và xử lý tình huống biên (ngữ cảnh đặc biệt AI bỏ sót)</li>
</ul>
<p>Điều này có nghĩa là, so với phương thức phát triển truyền thống, tôi tiết kiệm được khoảng <strong>99% thời gian viết code</strong>, có thể tập trung năng lượng vào thiết kế kiến trúc, kiểm soát quyết định và định vị vấn đề.</p>
<h2>3. Những cái hố đã giẫm phải</h2>
<p>Trong quá trình hợp tác với AI, tôi đã giẫm phải không ít hố. Những hố này không phải biểu hiện của việc AI thiếu năng lực, mà là do chúng ta hiểu chưa đủ về đặc tính của AI. Tóm lại, chủ yếu có các loại sau:</p>
<h3>Vấn đề thường gặp và cách đối phó</h3>
<p><strong>1. Ảo giác API (Hallucination)</strong></p>
<ul>
<li><strong>Hiện tượng</strong>: AI hư cấu ra API, hàm thư viện hoặc tham số hoàn toàn không tồn tại, viết ra code trông có vẻ hợp lý nhưng thực tế không chạy được.</li>
<li><strong>Ví dụ</strong>: Tên phương thức hoàn toàn không có trong tài liệu thư viện nào đó, hoặc chữ ký tham số sai.</li>
<li><strong>Đối phó</strong>: Tôi phải xác minh thủ công sự tồn tại thực sự của mỗi API then chốt, khi cần thiết phải tra cứu tài liệu chính thức. Khuyên bạn nên chỉ rõ trong prompt "sử dụng API tồn tại trong tài liệu chính thức".</li>
</ul>
<p><strong>2. Vá víu lặp lại trên giả định sai</strong></p>
<ul>
<li><strong>Hiện tượng</strong>: AI sẽ sửa đi sửa lại trên cơ sở hiểu sai, càng sửa càng rối nhưng mãi không thoát khỏi khung sai lầm.</li>
<li><strong>Ví dụ</strong>: Giả sử một trường nào đó là tùy chọn (optional), nhưng thực tế là bắt buộc (required). AI dựa vào giả định sai này để tạo code, sau đó phát hiện bug, liền vá víu lặp lại trên giả định sai này, sửa A rồi sửa B, sửa B lại sửa C.</li>
<li><strong>Đối phó</strong>: Tôi phải đích thân định vị nguyên nhân gốc, sau đó nói rõ cho nó "giả định trước đó của ngươi sai rồi, vấn đề thực sự nằm ở đây".</li>
</ul>
<p><strong>3. Thiết kế quá mức và trừu tượng không cần thiết</strong></p>
<ul>
<li><strong>Hiện tượng</strong>: Code do AI tạo ra chứa quá nhiều design pattern, hàm factory, decorator v.v., khiến độ phức tạp của code vượt xa nhu cầu.</li>
<li><strong>Đối phó</strong>: Khi review code xóa thẳng tay những trừu tượng không cần thiết này, giữ cho code đơn giản.</li>
</ul>
<p><strong>4. Vấn đề vệ sinh code</strong></p>
<ul>
<li><strong>Hiện tượng</strong>: Import vô dụng, định nghĩa hàm trùng lặp dư thừa, chú thích vô dụng, code chết (dead code).</li>
<li><strong>Đối phó</strong>: Cần dọn dẹp thủ công, kiến nghị nhấn mạnh trong prompt "code ngắn gọn, không dư thừa, không chú thích thừa".</li>
</ul>
<p><strong>5. Bỏ sót ngữ cảnh biên</strong></p>
<ul>
<li><strong>Hiện tượng</strong>: AI thực hiện "happy path" (trường hợp suôn sẻ), xử lý không chu đáo các tình huống biên như giá trị null, đầu vào bất thường, kịch bản đồng thời (concurrency).</li>
<li><strong>Đối phó</strong>: Bổ sung sau khi phát hiện ở giai đoạn test, hoặc liệt kê trước các ngữ cảnh biên cần xử lý trong prompt.</li>
</ul>
<h3>Cái hố lớn nhất: Vòng lặp debug vô hiệu, điểm mù tự nhận thức của mô hình</h3>
<p>Debug và giải quyết Bug là vấn đề không thể tránh khỏi trong bất kỳ phương thức coding nào. Mặc dù vibecoding được áp dụng thực tiễn, mọi người cũng dần <code>giải ảo</code> vibecoding, không còn coi vibecoding là thần khí vạn năng nữa. Ngược lại, họ nhận thức sâu sắc rằng vibecoding khi xuất code tốc độ cao thì cũng đang đưa bug vào hệ thống của bạn với xác suất lớn hơn và tốc độ cao hơn.</p>
<p>Đối với dự án từ 0 đến 1, có thể ban đầu bạn thấy vibecoding rất sướng, lượng lớn thiết kế chức năng nhanh chóng chuyển từ tài liệu thành code thực thi. Nhưng khi dự án của bạn ngày càng lớn, ngữ cảnh bạn đưa cho mô hình lớn cũng ngày càng dài, đồng thời sự phụ thuộc giữa các hệ thống/module/component cũng ngày càng phức tạp, một số vấn đề ẩn giấu trước đó trong hệ thống bắt đầu tích tụ và bùng nổ. Sẽ xuất hiện một số bug mà AI không dễ giải quyết như vậy.</p>
<p>Nếu bạn chỉ đưa thông tin báo lỗi cho AI, mà không phải tự mình đích thân phân tích định vị, AI có thể rơi vào <strong>vòng lặp debug vô hiệu</strong>, xuất hiện tình trạng <code>giật gấu vá vai</code>. Nếu bạn ép code đi sửa, mà bạn chỉ đóng vai trò người xác minh, thì bạn sẽ phát hiện mô hình đang làm việc vô ích lặp đi lặp lại, còn code của bạn càng sửa càng rối.</p>
<p><strong>Biểu hiện của vấn đề:</strong></p>
<p>Khi quy mô dự án tăng lên, quan hệ phụ thuộc phức tạp hóa, nếu bạn cứ một mực để mô hình tự giải quyết debug, sẽ rơi vào vòng xoáy ác tính:</p>
<ul>
<li><strong>Mô hình không định vị chính xác nguyên nhân gốc của báo lỗi</strong> — Vì chuỗi liên kết quá dài, ngữ cảnh quá phức tạp, hoặc thông tin báo lỗi bạn đưa quá trừu tượng bề mặt.</li>
<li><strong>Mô hình thiếu bộ nhớ bền vững</strong> — Mỗi vòng đối thoại là độc lập, không thể duy trì nhận thức trọn vẹn về toàn bộ vấn đề.</li>
<li><strong>Mô hình trông có vẻ đang liên tục vá lỗi, nhưng mãi không có khả năng thoát khỏi khung sai lầm</strong> — Sửa đi sửa lại dựa trên giả định sai.</li>
<li><strong>Bạn rơi vào vòng lặp kiểm thử - sửa chữa vô tận</strong> — Phối hợp với mô hình làm test hết lần này đến lần khác, nhưng mỗi lần test xong vấn đề vẫn còn đó.</li>
<li><strong>Code càng sửa càng loạn, thậm chí phát sinh bug mới</strong> — Mỗi lần sửa đổi đều có thể gây ra vấn đề mới, hình thành phản ứng dây chuyền.</li>
</ul>
<p>Đây chính là tình trạng "giật gấu vá vai":</p>
<pre><code>Lần sửa 1: Sửa A (dựa trên giả định sai)
Lần sửa 2: Sửa B (vì việc sửa A gây ra vấn đề mới)
Lần sửa 3: Sửa C (vì việc sửa B lại gây ra vấn đề mới)
...
Lần sửa N: Code càng ngày càng loạn, nhưng vấn đề gốc rễ mãi không được giải quyết
</code></pre>
<p>Nếu bạn chỉ đóng vai trò "người xác minh", để mô hình tự sửa, thì bạn sẽ thấy mô hình lặp đi lặp lại công dã tràng, còn code của bạn cũng nát bét.</p>
<p><strong>Tại sao lại như vậy?</strong></p>
<p>Điều này liên quan đến nguyên lý làm việc và hạn chế của AI:</p>
<ol>
<li>
<p><strong>Thiếu năng lực siêu nhận thức (Metacognition)</strong> — AI tạo văn bản dựa trên tự hồi quy (autoregressive), nó thiếu khả năng "suy nghĩ về suy nghĩ của chính mình". Khi nó tạo code dựa trên một giả định nào đó, giả định này trở thành cơ sở cho suy luận tiếp theo của nó. Kể cả khi giả định này sai, nó cũng rất khó tự nhận thức và hoài nghi giả định đó.</p>
</li>
<li>
<p><strong>Không có bộ nhớ bền vững</strong> — Mỗi vòng đối thoại là độc lập, mô hình không thể duy trì nhận thức trọn vẹn về vấn đề qua nhiều vòng đối thoại. Khi bạn nói "chỗ này vẫn có bug", mô hình có thể đã "quên" ngữ cảnh trước đó, chỉ có thể đoán dựa trên thông tin báo lỗi hiện tại.</p>
</li>
<li>
<p><strong>Chồng chất giả định sai</strong> — Mỗi vòng sửa đổi đều dựa trên đầu ra của vòng trước. Nếu giả định ở bước đầu tiên đã sai, tất cả các sửa đổi sau đó đều sẽ chồng chất trên nền tảng sai lầm này, hình thành một khung sai lầm ngày càng phức tạp. Mô hình không có khả năng "đập đi làm lại", chỉ có thể tiếp tục vá víu trên nền tảng sai lầm.</p>
</li>
</ol>
<p><strong>Cách giải quyết duy nhất: Bạn đích thân xuống tay debug</strong></p>
<p>Điều này rất then chốt —— không phải để AI sửa bug, mà là bạn tìm ra nguyên nhân gốc rễ trước. Các bước cụ thể:</p>
<ol>
<li>
<p><strong>Nhận diện tín hiệu nguy hiểm</strong> — Nếu phát hiện mô hình sửa đi sửa lại trên cùng một vấn đề quá 2-3 lần mà chưa xong, dừng lại ngay. Điều này cho thấy mô hình có thể đã rơi vào khung sai lầm.</p>
</li>
<li>
<p><strong>Tự định vị nguyên nhân gốc</strong> — Đây là bước quan trọng nhất. Thông qua log, breakpoint, trace code... để tìm ra nguyên nhân thực sự của vấn đề. Đừng chỉ nhìn thông tin báo lỗi bề mặt, phải hiểu:</p>
</li>
<li>Vấn đề xảy ra ở module nào?</li>
<li>Tại sao lại xảy ra?</li>
<li>
<p>Nguyên nhân gốc rễ là gì?</p>
</li>
<li>
<p><strong>Nói rõ nguyên nhân gốc cho mô hình</strong> — Đừng nói "đây có bug" hay "hãy sửa lỗi này", mà hãy chỉ rõ nguyên nhân gốc:</p>
</li>
</ol>
<blockquote>
<p>"Giả định trước đó của ngươi sai rồi. Vấn đề thực sự nằm ở đây: [mô tả cụ thể nguyên nhân gốc, bao gồm tại sao lại như vậy]. Dựa trên cách hiểu này, hãy triển khai lại phần code này."</p>
</blockquote>
<ol>
<li><strong>Để mô hình tạo lại dựa trên cách hiểu đúng</strong> — Một khi mô hình hiểu đúng nguyên nhân gốc, nó sẽ có thể thoát khỏi khung sai lầm, tạo ra code đúng.</li>
</ol>
<p><strong>Đây cũng là lý do tại sao vô lăng phải nằm trong tay người:</strong></p>
<p>Sự hiệu quả của Vibe Coding đến từ tốc độ xuất code cao của AI, nhưng điều này cũng đồng nghĩa với tốc độ nhập bug cao. Khi hệ thống trở nên phức tạp, bạn không thể chỉ là một "người xác minh" bị động nữa, mà bắt buộc phải là một "người ra quyết định" và "người định vị vấn đề" chủ động.</p>
<p>Bạn cần:</p>
<ul>
<li><strong>Kiểm soát phương hướng ở tầng kiến trúc</strong> — Đảm bảo thiết kế hệ thống hợp lý, ranh giới module rõ ràng.</li>
<li><strong>Đích thân xuống tay khi định vị vấn đề</strong> — Đây là quan trọng nhất. Khi xuất hiện bug, bạn phải tự phân tích, định vị, hiểu nguyên nhân gốc.</li>
<li><strong>Phát hiện thiết kế bất hợp lý khi review code</strong> — Kịp thời phát hiện thiết kế quá mức hoặc giả định sai của mô hình.</li>
<li><strong>Bổ sung ngữ cảnh biên khi test</strong> — Chủ động test, thay vì bị động chờ bug xuất hiện.</li>
</ul>
<p>Chỉ có như vậy, bạn mới thực sự phát huy được ưu thế của AI (xuất code tốc độ cao), đồng thời tránh được nhược điểm của nó (không thể tự sửa sai, thiếu siêu nhận thức).</p>
</body>
</html>
